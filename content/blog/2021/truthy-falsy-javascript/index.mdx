---
title: Truthy y Falsy en JavaScript
date: 2021-09-19
description: En JavaScript existe el concepto de Truthy y Falsy values. D√©jame explicarte en este art√≠culo de qu√© se trata.
tags: [javascript]
cover: cover.png
draft: false
---

<TLDR>

  Debido a la coerci√≥n en JavaScript cuando una expresi√≥n se eval√∫a como booleano (un *if*, la condici√≥n de un *while*, una ternaria, etc) el lenguaje convertir√° el valor en *true* o *false*. Hay casos concretos que dar√°n *false*:

  ```javascript
  0  // cero
  -0 // cero negativo
  0n // cero de tipo BigInt
  "" // cadena de text vac√≠a
  '' // cadena de text vac√≠a
  `` // cadena de text vac√≠a
  null
  undefined
  NaN
  ```

  Cualquier otro valor al ser evaluado como booleano devolver√° *true*.

  <JavaScriptRepl
    title="Ejemplos de falsy y truthy values"
    init={[
      "0 ? 'Soy truthy' : 'Soy falsy'",
      "-42 ? 'Soy truthy' : 'Soy falsy'"
    ]}
  />

</TLDR>

En JavaScript existe la coerci√≥n, que se trata de una conversi√≥n de tipos cuando se va a evaluar una variable. Por ejemplo, si vamos a comparar entre un n√∫mero y una cadena de texto:

<JavaScriptRepl
  title="Ejemplos de coerci√≥n"
  init={[
    "'1' == 1",
    "'1' === 1"
  ]}
/>

Como vemos en el primer caso nos devuelve `true` y en el segundo `false`. La diferencia entre `==` y `===` es que `==` hace una coerci√≥n de tipos a la hora de comparar. Lo mismo pasa en casos negativos:

<JavaScriptRepl
  title="Ejemplos de coerci√≥n"
  init={[
    "'1' != 1",
    "'1' !== 1"
  ]}
/>

En estos ejemplos cuando comparamos n√∫meros y cadenas de texto, pero, ¬øqu√© pasa si evaluamos variables como si fueran booleanos?

<JavaScriptRepl
  title="Coerci√≥n de booleanos"
  init={[
    "0 ? 'Soy truthy' : 'Soy falsy'",
    "-42 ? 'Soy truthy' : 'Soy falsy'"
  ]}
/>

Lo que pasa es que JavaScript trata de convertir la variable a booleano, ya que est√°s evalu√°ndola como una condici√≥n. En la pr√°ctica es lo mismo que tratar de hacer `Boolean(0)`:

<JavaScriptRepl
  title="Convirtiendo a booleano"
  init={[
    "Boolean(0)",
    "Boolean(-42)"
  ]}
/>

Por eso en JavaScript se habla de valores *truthy* y *falsy*, que no son *true* o *false*, pero si son evaluados como booleanos se comportan como tales. Esto puede conllevar a problemas, ya que un valor es *truthy* o *falsy* dependiendo de c√≥mo est√° siendo evaluado:

<JavaScriptRepl
  title="Un valor puede ser falsy dependiendo de c√≥mo sea evaluado"
  init={[
    "const zeroNumber = 1 - 1",
    "zeroNumber + 1",
    "Boolean(zeroNumber)",
    "const zeroString = String(zeroNumber)",
    "Boolean(zeroString)"
  ]}
/>

La parte positiva es que los valores que pueden ser *falsy* son limitados:

```javascript
0  // cero
-0 // cero negativo
0n // cero de tipo BigInt
"" // cadena de text vac√≠a
'' // cadena de text vac√≠a
`` // cadena de text vac√≠a
null
undefined
NaN
```

Por otro lado, todo valor que no es *falsy* es *truthy*:

<JavaScriptRepl
  title="Valores truthy"
  init={[
    "Boolean(1)",
    "Boolean('En un lugar de la Mancha...')",
    "Boolean({})",
    "Boolean([])",
    "Boolean(class Test {})",
    "Boolean(() => {})",
  ]}
/>

Saber esto te ayudar√° a mejorar la forma en la que construyes tus condicionales en JavaScript. Por ejemplo, imagina que te han pedido que para un usuario de la plataforma en la que est√°s trabajando muestre un mensaje con su saldo. En caso de que el usuario no tenga saldo, que no que sea 0, significa que todav√≠a no ha activado su cuenta por lo que deber√≠a mostrar un mensaje notific√°ndolo. Teniendo todo esto en cuenta hemos hecho esta funci√≥n:

```javascript
function parseBalance({name, balance}) {
  if (balance) {
    return `El saldo de ${name} es ${balance.toFixed(2)} ‚Ç¨.`
  } else {
    return `La cuenta de ${name} no ha sido activada.`
  }
}
```

Ahora vamos a probar con diferentes combinaciones para ver si podemos tener alg√∫n resultado inesperado:

<JavaScriptRepl
  title="Mostrar saldo del usuario"
  loadToScope={[
    `const parseBalance = ({name, balance}) => {
        if (balance) {
          return 'El saldo de '+name+' es '+balance.toFixed(2)+' ‚Ç¨.'
        } else {
          return 'La cuenta de '+name+' no ha sido activada.'
        }
    }`,
  ]}
  init={[
    "parseBalance({name: 'Carlos', balance: 120})",
    "parseBalance({name: 'Juan'})",
    "parseBalance({name: 'Pepe', balance: 0})",
  ]}
/>

Uy, parece ser que en el caso de Pepe ha pasado algo que no deber√≠a. Seg√∫n lo que nos han dicho Pepe deber√≠a tener la cuenta activada, ya que nos han pasado el saldo de su cuenta. Lo que pasa es que su saldo es `0`, lo cual al pasar por nuestro `if` se eval√∫a como `false`. Arreglar esto es f√°cil, s√≥lo tenemos que comprobar que el saldo no sea `undefined`:

```javascript
function parseBalance({name, balance}) {
  if (balance !== undefined) {
    return `El saldo de ${name} es ${balance.toFixed(2)} ‚Ç¨.`
  } else {
    return `La cuenta de ${name} no ha sido activada.`
  }
}
```

<JavaScriptRepl
  title="Mostrar saldo del usuario"
  loadToScope={[
    `const parseBalance = ({name, balance}) => {
        if (balance !== undefined) {
          return 'El saldo de '+name+' es '+balance.toFixed(2)+' ‚Ç¨.'
        } else {
          return 'La cuenta de '+name+' no ha sido activada.'
        }
    }`,
  ]}
  init={[
    "parseBalance({name: 'Carlos', balance: 120})",
    "parseBalance({name: 'Juan'})",
    "parseBalance({name: 'Pepe', balance: 0})",
  ]}
/>

Ahora s√≠ funciona como nos ha pedido. Es un ejemplo muy b√°sico, pero creo que refleja bien el problema de no controlar los valores *falsy*. Resumi√©ndolo: **el problema es que a veces un *falsy* value puede ser un valor v√°lido en el dominio de nuestra aplicaci√≥n, llevando a errores inesperados.** Si el caso de Pepe hubiera sido real habr√≠a intentado una y otra vez activar su cuenta, contactado con Atenci√≥n al Cliente o dejado de usar la aplicaci√≥n directamente.

Espero que esto te haya ayudado a que partir de ahora le des una vuelta de m√°s cuando tengas que escribir un condicional en JavaScript üòâ.
